<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>控制器</title>
      <link href="/2022/05/11/%E6%8E%A7%E5%88%B6%E5%99%A8/"/>
      <url>/2022/05/11/%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="控制器类型"><a href="#控制器类型" class="headerlink" title="控制器类型"></a>控制器类型</h1><p>● ReplicationController与ReplicaSet<br>● Deployment<br>● DaemonSet<br>● StatefulSet<br>● Job/Cronjob<br>● Horizontal Pod Autoscaling</p><h2 id="ReplicationController与ReplicaSet"><a href="#ReplicationController与ReplicaSet" class="headerlink" title="ReplicationController与ReplicaSet"></a>ReplicationController与ReplicaSet</h2><p>ReplicationController（RC）用来确保容器应用的副本数始终保持在用户自定义的副本数，即如果有容器异常退出，回自动创建新的pod来替代；而如果异常多出来的容器也会自动回收；</p><p>在新的版本的kubernetes中建议使用ReplicaSet来取代ReplicationController。ReplicaSet跟ReplicationController没有本质的不同，只是名字不一样，并且ReplicaSet支持集合式的selector；</p><h2 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h2><p>Deployment为pod和replicaset提供了 声明式（declarative）方法，用来替代之前的ReplicationController来方便的管理应用。典型的应用场景包括：<br>● 定义Deployment来创建pod和ReplicaSet<br>● 滚动升级和回滚应用<br>● 扩容和缩容<br>● 暂停和继续Deployment</p><h3 id="RS和Deployment的关联"><a href="#RS和Deployment的关联" class="headerlink" title="RS和Deployment的关联"></a>RS和Deployment的关联</h3><p><img src="/2022/05/11/%E6%8E%A7%E5%88%B6%E5%99%A8/hexo\blog\source_posts\控制器\1.png"></p><h3 id="部署Deployment"><a href="#部署Deployment" class="headerlink" title="部署Deployment"></a>部署Deployment</h3><h4 id="创建Nginx-deployment"><a href="#创建Nginx-deployment" class="headerlink" title="创建Nginx-deployment"></a>创建Nginx-deployment</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-deployment</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-deployment</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.7.9</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create -f nginx-deployment.yaml --record </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--record可以记录命令，方便查看每次的revision</span></span><br></pre></td></tr></table></figure><h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl scale deployment nginx-deployment --replicas 3</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果集群支持Horizontal pod autoscaling 的话，还可以设置自动扩展</span></span><br><span class="line">kubectl autoscale deployment nginx-deployment --min=2 --max=3 --cpu-percent=80</span><br></pre></td></tr></table></figure><h3 id="更新Deployment"><a href="#更新Deployment" class="headerlink" title="更新Deployment"></a>更新Deployment</h3><h4 id="镜像更新"><a href="#镜像更新" class="headerlink" title="镜像更新"></a>镜像更新</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">方式一</span></span><br><span class="line">kubectl set image deployment/nginx-deployment ngin-deployment=nginx:1.9.1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">方式二</span></span><br><span class="line">kubectl edit deployment/nginx-deployment</span><br></pre></td></tr></table></figure><h4 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl rollout undo deployment/nginx-deployment</span></span><br><span class="line">deployment.apps/nginx-deployment rolled back</span><br></pre></td></tr></table></figure><h4 id="查看rollout的状态"><a href="#查看rollout的状态" class="headerlink" title="查看rollout的状态"></a>查看rollout的状态</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl rollout status deployment/nginx-deployment</span></span><br><span class="line">deployment &quot;nginx-deployment&quot; successfully rolled out</span><br></pre></td></tr></table></figure><h4 id="查看历史RS"><a href="#查看历史RS" class="headerlink" title="查看历史RS"></a>查看历史RS</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get rs</span></span><br><span class="line">NAME                          DESIRED   CURRENT   READY   AGE</span><br><span class="line">nginx-deployment-6588fd458d   2         2         2       25m</span><br><span class="line">nginx-deployment-6847fcfd4b   0         0         0       14m</span><br></pre></td></tr></table></figure><h3 id="Deployment更新策略"><a href="#Deployment更新策略" class="headerlink" title="Deployment更新策略"></a>Deployment更新策略</h3><p>Deployment可以保证在升级时只有一定数量的Pod是down的。默认情况下，它会确保至少有比期望的Pod数量少一个是up状态（最多一个不可用）</p><p>Deployment同时也可以确保只创建出超过期望数量的一定数量的Pod。默认情况下，它会确保最多比期望的Pod数量多一个是up状态（最多一个surge）</p><h3 id="Rollover（多个Rollout并行）"><a href="#Rollover（多个Rollout并行）" class="headerlink" title="Rollover（多个Rollout并行）"></a>Rollover（多个Rollout并行）</h3><p>假如你创建了一个有5个ngin:1.7.9 replica的Deployment，但是当时还只有3个nginx:1.7.9的replica创建出来的时候你就开始更新含有5个nginx:1.9.1 replica的Deployment。<br>在这种情况下，Deployment会立即杀掉已创建的3个nginx:1.7.9的pod，并开始创建nginx:1.9.1的pod。他不会等到所有的5个nginx:1.7.9的pod都创建以后才开始更新</p><h3 id="清理Policy"><a href="#清理Policy" class="headerlink" title="清理Policy"></a>清理Policy</h3><p>你可以设置.spec.revisionHistoryLimit项来指定deployment最多保留多少revision历史记录。默认的会保留所有的revision；如果将该项设置为0，deployment就不允许回退</p><h2 id="StatefulSet"><a href="#StatefulSet" class="headerlink" title="StatefulSet"></a>StatefulSet</h2><p>StatefulSet作为Controller为pod提供唯一的标识，他可以保证部署和scale的顺序<br>StatefulSet是为了解决有状态服务的问题（对应Deployment和ReplicaSet是为无状态服务设计的），其应用场景包括：<br>● 稳定的持久化存储，即Pod重新调度后还是能访问到相同的持久化数据，基于PVC来实现<br>● 稳定的网络标志，即Pod重新调度后其PodName和HostName不变，基于Headless Service（即没有Cluster IP的Service）来实现<br>● 有序部署，有序扩展，即Pod是有顺序的，在部署或者扩展的时候要依据定义的顺序依次进行（即从0到N-1，在下一个Pod运行之前所有之前的Pod必须都是Running和Ready状态），基于init containers来实现<br>● 有序收缩，有序删除（即从N-1到0）</p><p>==有状态应用 VS 无状态应用：主要在于网络和存储两方面==</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">无状态应用，例如nginx。主要可以任意飘逸，每个副本是对等的</span><br><span class="line">有状态应用，例如etcd、zookeeper、mysql主从，每个副本是不对等</span><br></pre></td></tr></table></figure><p>1、headless  service：不同于平常service在于不需要cluster IP，也就是在yaml中定义spec.clusterIP为None</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">headless-service</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">headless-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">headless-service</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">statefulset-web</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">headless-service</span></span><br><span class="line">  <span class="attr">serviceName:</span> <span class="string">&quot;headless-service&quot;</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">headless-service</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">headless-pod</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">headless-pod</span></span><br></pre></td></tr></table></figure><p><img src="/2022/05/11/%E6%8E%A7%E5%88%B6%E5%99%A8/hexo\blog\source_posts\控制器\2.png"></p><p>上图中的pod的编号是0,1,对应启动顺序<br>利用nslookup来确认statefulset唯一稳定的网络ID</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ClusterIP A记录格式：</span><br><span class="line">  &lt;service-name&gt;.&lt;namespace-name&gt;.svc.cluster.local</span><br><span class="line">ClusterIP=None A记录格式：</span><br><span class="line">  &lt;statefulsetName-index&gt;.&lt;service-name&gt; .&lt;namespace-name&gt;.svc.cluster.local</span><br><span class="line">     示例：web-0.nginx.default.svc.cluster.local</span><br></pre></td></tr></table></figure><p><img src="/2022/05/11/%E6%8E%A7%E5%88%B6%E5%99%A8/hexo\blog\source_posts\控制器\3.png"></p><p>上图中headless的service的dnsIP指定的就是每个pod的IP。但普通service的dnsIP 是对应的service的clusterIP</p><p>确认statefulset稳定的存储—-也就是每个pod都是独立的PV</p><p>1、StatefulSet的存储卷使用VolumeClaimTemplate创建， 称为卷申请模板，当StatefulSet使用VolumeClaimTemplate 创建一个PersistentVolume时，同样也会为每个Pod分配 并创建一个编号的PVC</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">headless-service</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">headless-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">headless-service</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">statefulset-web</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">headless-service</span></span><br><span class="line">  <span class="attr">serviceName:</span> <span class="string">&quot;headless-service&quot;</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">headless-service</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">headless-pod</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">headless-pod</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">www</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line">  <span class="attr">volumeClaimTemplates:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">www</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">accessModes:</span> [<span class="string">&quot;ReadWriteOnce&quot;</span>]</span><br><span class="line">      <span class="attr">storageClassName:</span> <span class="string">&quot;managed-nfs-storage&quot;</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">requests:</span></span><br><span class="line">          <span class="attr">storage:</span> <span class="string">1Gi</span></span><br></pre></td></tr></table></figure><p><img src="/2022/05/11/%E6%8E%A7%E5%88%B6%E5%99%A8/hexo\blog\source_posts\控制器\4.png"><br>在k8s中部署有状态分布式应用主要解决的问题：<br>1、通过一个镜像怎么自动化生成各自独立的配置文件<br>2、部署这个应用在k8s中的一个拓扑图</p><h2 id="DaemonSet"><a href="#DaemonSet" class="headerlink" title="DaemonSet"></a>DaemonSet</h2><p>DaemonSet确保全部（或者一些）node上运行一个pod的副本。当有node加入集群时，也为他们新增一个pod。当有node从集群移除时，这些pod也会被回收。删除的DaemonSet将会删除它创建的所有pod。</p><p>使用DaemonSet的一些典型用法：<br>● 运行集群存储daemon，例如在每个Node上运行glusterd、ceph<br>● 在每个Node上运行日志收集daemon，例如fluentd、logstash<br>● 在每个Node上运行监控daemon，例如Prometheus Node Exporter、collectd、datadog代理、New Relic代理，或Ganglia gmod</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">fluentd-elasticsearch</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">fluentd-logging</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">fluentd-elasticsearch</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">fluentd-elasticsearch</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">tolerations:</span></span><br><span class="line">      <span class="comment"># this toleration is to have the daemonset runnable on master nodes</span></span><br><span class="line">      <span class="comment"># remove it if your masters can&#x27;t run pods</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">node-role.kubernetes.io/master</span></span><br><span class="line">        <span class="attr">operator:</span> <span class="string">Exists</span></span><br><span class="line">        <span class="attr">effect:</span> <span class="string">NoSchedule</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">fluentd-elasticsearch</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">quay.io/fluentd_elasticsearch/fluentd:v2.5.2</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">200Mi</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">200Mi</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">varlog</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/log</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">varlibdockercontainers</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/lib/docker/containers</span></span><br><span class="line">          <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">terminationGracePeriodSeconds:</span> <span class="number">30</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">varlog</span></span><br><span class="line">        <span class="attr">hostPath:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/var/log</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">varlibdockercontainers</span></span><br><span class="line">        <span class="attr">hostPath:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/var/lib/docker/containers</span></span><br></pre></td></tr></table></figure><h2 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h2><p>Job负责批处理任务，即仅执行一次的任务，它保证批处理任务的一个或多个pod成功结束<br>1、特殊说明<br>● spec.template 格式同Pod<br>● RestartPolicy仅支持Nerver或者OnFailure<br>● 单个Pod时，默认Pod成功运行后Job即结束<br>● .spec.completions标志Job结束需要成功运行的Pod个数，默认为1<br>● .spec.parallelism标志并行运行的Pod的个数，默认为1<br>● spec.activeDeadlineSeconds标志失败Pod的重试最大时间，超过这个时间不会继续重试<br>● .spec.ttlSecondsAfterFinished自动清理完成的Job的TTL机制，如果该字段设置为 0，Job 在结束之后立即成为可被自动删除的对象。 如果该字段没有设置，Job 不会在结束之后被 TTL 控制器自动清除<br>2、示例：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pi</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">pi</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">perl</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">&quot;perl&quot;</span>,  <span class="string">&quot;-Mbignum=bpi&quot;</span>, <span class="string">&quot;-wle&quot;</span>, <span class="string">&quot;print bpi(2000)&quot;</span>]</span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br><span class="line">  <span class="attr">backoffLimit:</span> <span class="number">4</span> </span><br><span class="line"><span class="comment">#backoffLimit表示回退限制，失效回退的限制值默认为 6，可以指定重试几次后将 Job 标记为失败</span></span><br></pre></td></tr></table></figure><p>以机器可读的方式列举属于某job的全部pods,可以使用：pods=$(kubectl get pods –selector=job-name=pi –output=jsonpath=’{.items[*].metadata.name}’);echo $pods，查看其中某个Pod的标准输出：kubectl logs $pods</p><h2 id="CronJob"><a href="#CronJob" class="headerlink" title="CronJob"></a>CronJob</h2><p>CronJob管理基于时间的job，即：<br>● 在给定时间点至运行一次<br>● 周期性的在给定时间点运行<br>使用前提条件：<strong>当前使用的kubernetes集群，版本&gt;=1.8(对CronJob)。对于先前版本的集群，版本&lt;1.8，启动ApiServer时，通过传递选项–runtime-config=batch/v2alpha1API</strong></p><p>典型的用法如下所示：<br>● 在给定的时间点调度Job运行<br>● 创建周期性运行的Job，例如：数据库备份、发生邮件</p><p>1、特殊说明<br>● .spec.schedule ：调度，必需字段，指定运行周期，格式同Cron<br>● .spec.jobTemplate：Job模板，必需字段，指定需要运行的任务，格式同Job<br>● .spec.startingDeadlineSeconds：启动Job的期限（秒级别），该字段是可选的。如果因为任何原因错过了被调度的时间，那么错过执行时间的Job将会被认为是失败的；如果没有指定，则没有期限<br>● .spec.concurrencyPolicy：并发策略，该字段也是可选的。他指定了如何处理被Cron Job创建的Job的并发执行，只允许下面策略的一种：<br>  ○ Allow（默认）：允许并发允许Job<br>  ○ Forbid：禁止并发执行，如果前一个没有完成，则直接跳过下一个<br>  ○ Replace：取消当前正在允许的Job，用一个新的替换<br>== 注意，当前策略只能应用于同一个Cron Job创建的Job。如果存在多个Cron Job，他们创建的Job之间总是允许并发执行的<br>● .spec.suspend：挂起，该字段也是可选的。如果设置为TRUE，后续所有的执行都会被挂起，他对已经开始执行的Job不起作用。默认值为false<br>● .spec.successfulJobsHistoryLimit和.spec.failedJobsHistoryLimit：历史限制，是可选字段，他们指定了可以保留多少完成和失败的Job。默认情况下，他们分别设置为3和1，设置限制的值为0，相关类型的Job完成后将不会保留<br>2、示例：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CronJob</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hello</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="string">&quot;*/1 * * * *&quot;</span></span><br><span class="line">  <span class="attr">jobTemplate:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">template:</span></span><br><span class="line">        <span class="attr">spec:</span></span><br><span class="line">          <span class="attr">containers:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">hello</span></span><br><span class="line">            <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">            <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">            <span class="attr">command:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">/bin/sh</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">-c</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">date;</span> <span class="string">echo</span> <span class="string">Hello</span> <span class="string">from</span> <span class="string">the</span> <span class="string">Kubernetes</span> <span class="string">cluster</span></span><br><span class="line">          <span class="attr">restartPolicy:</span> <span class="string">OnFailure</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get cronjob</span></span><br><span class="line">NAME    SCHEDULE      SUSPEND   ACTIVE   LAST SCHEDULE   AGE</span><br><span class="line">hello   */1 * * * *   False     1        3s              6m50s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get <span class="built_in">jobs</span></span></span><br><span class="line">NAME               COMPLETIONS   DURATION   AGE</span><br><span class="line">hello-1628066820   1/1           1s         2m11s</span><br><span class="line">hello-1628066880   1/1           2s         71s</span><br><span class="line">hello-1628066940   1/1           1s         10s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pods=$(kubectl get pods --selector=job-name=hello-1628066760 --output=jsonpath=<span class="string">&#x27;&#123;.items[*].metadata.name&#125;&#x27;</span>);<span class="built_in">echo</span> <span class="variable">$pods</span></span></span><br><span class="line">hello-1628066760-z5kqb</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl logs <span class="variable">$pods</span></span></span><br><span class="line">Wed Aug  4 08:46:02 UTC 2021</span><br><span class="line">Hello from the Kubernetes cluster</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注意：删除cornjob的时候不会自动删除job，可以使用kubectl delete job 来删除</span></span><br></pre></td></tr></table></figure><h2 id="Horizontal-Pod-Autoscaling"><a href="#Horizontal-Pod-Autoscaling" class="headerlink" title="Horizontal Pod Autoscaling"></a>Horizontal Pod Autoscaling</h2><p>应用的资源使用率通常都有高峰和低谷的时候，如何削峰填谷，提高集群的整体资源利用率，让service中的Pod个数自动调整呢？这就依赖于Horizontal Pod Autoscaling了，顾名思义，使Pod水平自动缩放<br><a href="https://www.yuque.com/cherishmelon/xy3e1p/agza6z?inner=79ebf1b6">https://www.yuque.com/cherishmelon/xy3e1p/agza6z?inner=79ebf1b6</a></p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
          <category> 控制器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes集群部署</title>
      <link href="/2022/05/09/Kubernetes%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/"/>
      <url>/2022/05/09/Kubernetes%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><pre><code>官方文档：www.kubernetes.io博客文章：https://www.cnblogs.com/menkeyi/p/7134460.html</code></pre><h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Master节点：</span><br><span class="line">- kube-apiserver</span><br><span class="line">- controller-manager</span><br><span class="line">- scheduler</span><br><span class="line">- etcd</span><br><span class="line"></span><br><span class="line">Node节点：</span><br><span class="line">- kubelet</span><br><span class="line">- kube-proxy</span><br><span class="line">- Docker</span><br></pre></td></tr></table></figure><h1 id="kudeadm安装"><a href="#kudeadm安装" class="headerlink" title="kudeadm安装"></a>kudeadm安装</h1><p>kubeadm是官方社区推出的一个用于快速部署kubernetes集群的工具。<br>这个工具能通过两条指令完成一个kubernetes集群的部署：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个 Master 节点</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubeadm init</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将一个 Node 节点加入到当前集群中</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubeadm <span class="built_in">join</span> &lt;Master节点的IP和端口</span> </span><br></pre></td></tr></table></figure><h2 id="安装要求"><a href="#安装要求" class="headerlink" title="安装要求"></a>安装要求</h2><p>在开始之前，部署Kubernetes集群机器需要满足以下几个条件：<br>● 一台或多台机器，操作系统 CentOS7.x-86_x64<br>● 硬件配置：2GB或更多RAM，2个CPU或更多CPU，硬盘30GB或更多<br>● 集群中所有机器之间网络互通<br>● 可以访问外网，需要拉取镜像<br>● 禁止swap分区</p><h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><p>角色    IP<br>k8s-master    192.168.31.61<br>k8s-node1    192.168.31.62<br>k8s-node2    192.168.31.63</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">关闭防火墙：</span><br><span class="line">```shell</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl stop firewalld</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl <span class="built_in">disable</span> firewalld</span></span><br><span class="line"></span><br><span class="line">关闭selinux：</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed -i <span class="string">&#x27;s/enforcing/disabled/&#x27;</span> /etc/selinux/config  <span class="comment"># 永久</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">setenforce 0  <span class="comment"># 临时</span></span></span><br><span class="line"></span><br><span class="line">关闭swap：</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">swapoff -a  <span class="comment"># 临时</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim /etc/fstab  <span class="comment"># 永久</span></span></span><br><span class="line"></span><br><span class="line">设置主机名：</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hostnamectl set-hostname &lt;hostname&gt;</span></span><br><span class="line"></span><br><span class="line">在master添加hosts：</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> &gt;&gt; /etc/hosts &lt;&lt; <span class="string">EOF</span></span></span><br><span class="line">192.168.31.61 k8s-master</span><br><span class="line">192.168.31.62 k8s-node1</span><br><span class="line">192.168.31.63 k8s-node2</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">将桥接的IPv4流量传递到iptables的链：</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt; EOF</span></span></span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sysctl --system  <span class="comment"># 生效</span></span></span><br><span class="line"></span><br><span class="line">时间同步：</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum install ntpdate -y</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ntpdate time.windows.com</span></span><br></pre></td></tr></table></figure><h2 id="所有节点安装Docker-kubeadm-kubelet"><a href="#所有节点安装Docker-kubeadm-kubelet" class="headerlink" title="所有节点安装Docker/kubeadm/kubelet"></a>所有节点安装Docker/kubeadm/kubelet</h2><p>Kubernetes默认CRI（容器运行时）为Docker，因此先安装Docker。</p><h3 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum -y install docker-ce-18.06.1.ce-3.el7</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl <span class="built_in">enable</span> docker &amp;&amp; systemctl start docker</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker --version</span></span><br><span class="line">Docker version 18.06.1-ce, build e68fc7a</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">添加</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> &gt; /etc/docker/daemon.json &lt;&lt; <span class="string">EOF</span></span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://b9pmyelo.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>之后需要重启docker，利用docker info查看配置的加速源是否生效</p><h3 id="添加阿里云YUM软件源"><a href="#添加阿里云YUM软件源" class="headerlink" title="添加阿里云YUM软件源"></a>添加阿里云YUM软件源</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; <span class="string">EOF</span></span></span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ubuntu系统配置源并安装：</p><p><a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/#%E5%AE%89%E8%A3%85-kubeadm-kubelet-%E5%92%8C-kubectl">https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/#%E5%AE%89%E8%A3%85-kubeadm-kubelet-%E5%92%8C-kubectl</a></p><h3 id="安装kubeadm，kubelet和kubectl"><a href="#安装kubeadm，kubelet和kubectl" class="headerlink" title="安装kubeadm，kubelet和kubectl"></a>安装kubeadm，kubelet和kubectl</h3><p>由于版本更新频繁，这里指定版本号部署：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum install -y kubelet-1.18.0 kubeadm-1.18.0 kubectl-1.18.0</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl <span class="built_in">enable</span> kubelet</span></span><br></pre></td></tr></table></figure><h2 id="部署Kubernetes-Master"><a href="#部署Kubernetes-Master" class="headerlink" title="部署Kubernetes Master"></a>部署Kubernetes Master</h2><p>参考文档： <a href="https://kubernetes.io/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/#config-file">https://kubernetes.io/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/#config-file</a></p><p><a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#initializing-your-control-plane-node">https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#initializing-your-control-plane-node</a></p><p>在192.168.31.61（Master）执行。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubeadm init \</span></span><br><span class="line"><span class="language-bash">  --apiserver-advertise-address=192.168.31.61 \</span></span><br><span class="line"><span class="language-bash">  --image-repository registry.aliyuncs.com/google_containers \</span></span><br><span class="line"><span class="language-bash">  --kubernetes-version v1.18.0 \</span></span><br><span class="line"><span class="language-bash">  --service-cidr=10.96.0.0/12 \</span></span><br><span class="line"><span class="language-bash">  --pod-network-cidr=10.244.0.0/16 \</span></span><br><span class="line"><span class="language-bash">  --ignore-preflight-errors=all</span></span><br></pre></td></tr></table></figure><p>由于默认拉取镜像地址k8s.gcr.io国内无法访问，这里指定阿里云镜像仓库地址。</p><p>或者使用配置文件引导：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vi kubeadm.conf</span></span><br><span class="line">apiVersion: kubeadm.k8s.io/v1beta2</span><br><span class="line">kind: ClusterConfiguration</span><br><span class="line">kubernetesVersion: v1.18.0</span><br><span class="line">imageRepository: registry.aliyuncs.com/google_containers </span><br><span class="line">networking:  </span><br><span class="line">  podSubnet: 10.244.0.0/16   </span><br><span class="line">  serviceSubnet: 10.96.0.0/12 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubeadm init --config kubeadm.conf --ignore-preflight-errors=all</span></span><br></pre></td></tr></table></figure><p>使用kubectl工具：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get nodes</span></span><br></pre></td></tr></table></figure><h2 id="加入Kubernetes-Node"><a href="#加入Kubernetes-Node" class="headerlink" title="加入Kubernetes Node"></a>加入Kubernetes Node</h2><p><a href="https://kubernetes.io/zh/docs/reference/setup-tools/kubeadm/kubeadm/">https://kubernetes.io/zh/docs/reference/setup-tools/kubeadm/kubeadm/</a></p><p>在192.168.31.62/63（Node）执行。</p><p>向集群添加新节点，执行在kubeadm init输出的kubeadm join命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubeadm <span class="built_in">join</span> 192.168.31.61:6443 --token esce21.q6hetwm8si29qxwn \    --discovery-token-ca-cert-hash sha256:00603a05805807501d7181c3d60b478788408cfe6cedefedb1f97569708be9c5</span></span><br></pre></td></tr></table></figure><p>默认token有效期为24小时，当过期之后，该token就不可用了。这时就需要重新创建token，操作如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kubeadm token create<span class="comment"># kubeadm token list</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">openssl x509 -pubkey -<span class="keyword">in</span> /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null | openssl dgst -sha256 -hex | sed <span class="string">&#x27;s/^.* //&#x27;</span>63bca849e0e01691ae14eab449570284f0c3ddeea590f8da988c07fe2729e924</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kubeadm <span class="built_in">join</span> 192.168.31.61:6443 --token nuja6n.o3jrhsffiqs9swnu --discovery-token-ca-cert-hash sha256:63bca849e0e01691ae14eab449570284f0c3ddeea590f8da988c07fe2729e924</span></span><br></pre></td></tr></table></figure><p>kubeadm token create –print-join-command</p><p><a href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm-join/">https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm-join/</a></p><h2 id="网络方案（CNI）"><a href="#网络方案（CNI）" class="headerlink" title="网络方案（CNI）"></a>网络方案（CNI）</h2><p><a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#pod-network">https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#pod-network</a></p><p>注意：只需要部署下面其中一个，推荐Calico。</p><h3 id="Calico"><a href="#Calico" class="headerlink" title="Calico"></a>Calico</h3><p>Calico是一个纯三层的数据中心网络方案，Calico支持广泛的平台，包括Kubernetes、OpenStack等。</p><p>Calico 在每一个计算节点利用 Linux Kernel 实现了一个高效的虚拟路由器（ vRouter） 来负责数据转发，而每个 vRouter 通过 BGP 协议负责把自己上运行的 workload 的路由信息向整个 Calico 网络内传播。</p><p>此外，Calico  项目还实现了 Kubernetes 网络策略，提供ACL功能。</p><p><a href="https://docs.projectcalico.org/getting-started/kubernetes/quickstart">https://docs.projectcalico.org/getting-started/kubernetes/quickstart</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://docs.projectcalico.org/manifests/calico.yaml</span><br></pre></td></tr></table></figure><p>下载完后还需要修改里面配置项：</p><p>● 定义Pod网络（CALICO_IPV4POOL_CIDR），与前面pod CIDR配置一样<br>● 选择工作模式（CALICO_IPV4POOL_IPIP），支持BGP（Never）、IPIP（Always）、CrossSubnet（开启BGP并支持跨子网）</p><p>修改完后应用清单：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kubectl apply -f calico.yaml<span class="comment"># kubectl get pods -n kube-system</span></span></span><br></pre></td></tr></table></figure><h3 id="Flannel"><a href="#Flannel" class="headerlink" title="Flannel"></a>Flannel</h3><p>Flannel是CoreOS维护的一个网络组件，Flannel为每个Pod提供全局唯一的IP，Flannel使用ETCD来存储Pod子网与Node IP之间的关系。flanneld守护进程在每台主机上运行，并负责维护ETCD信息和路由数据包。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br><span class="line">sed -i -r &quot;s#quay.io/coreos/flannel:.*-amd64#lizhenliang/flannel:v0.11.0-amd64#g&quot; kube-flannel.yml</span><br></pre></td></tr></table></figure><p>修改国内镜像仓库。</p><h2 id="测试kubernetes集群"><a href="#测试kubernetes集群" class="headerlink" title="测试kubernetes集群"></a>测试kubernetes集群</h2><p>● 验证Pod工作<br>● 验证Pod网络通信<br>● 验证DNS解析<br>在Kubernetes集群中创建一个pod，验证是否正常运行：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl create deployment nginx --image=nginx</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl expose deployment nginx --port=80 --<span class="built_in">type</span>=NodePort</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pod,svc</span></span><br></pre></td></tr></table></figure><p>访问地址：<a href="http://NodeIP:Port">http://NodeIP:Port</a><br>测试DNS：kubectl run dns-test -it –rm –image=busybox:1.28.4 – sh，进去pod后nslookup 百度地址</p><h2 id="部署-Dashboard"><a href="#部署-Dashboard" class="headerlink" title="部署 Dashboard"></a>部署 Dashboard</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.3/aio/deploy/recommended.yaml</span></span><br></pre></td></tr></table></figure><p>默认Dashboard只能集群内部访问，修改Service为NodePort类型，暴露到外部：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">labels:</span>    </span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span>  </span><br><span class="line"><span class="attr">name:</span> <span class="string">kubernetes-dashboard</span>  </span><br><span class="line"><span class="attr">namespace:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">ports:</span>    </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">443</span>      </span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8443</span>      </span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">30001</span>  </span><br><span class="line">  <span class="attr">selector:</span>    </span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span>  </span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br></pre></td></tr></table></figure><p>访问地址：<a href="https://nodeip:30001/">https://NodeIP:30001</a><br>创建service account并绑定默认cluster-admin管理员集群角色：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create serviceaccount dashboard-admin -n kube-system</span><br><span class="line">kubectl create clusterrolebinding dashboard-admin --clusterrole=cluster-admin --serviceaccount=kube-system:dashboard-admin</span><br><span class="line">kubectl describe secrets -n kube-system $(kubectl -n kube-system get secret | awk &#x27;/dashboard-admin/&#123;print $1&#125;&#x27;)</span><br></pre></td></tr></table></figure><p>使用输出的token登录Dashboard。<br>后续如果忘记的话可以，<code> kubectl get secrets -n kube-system</code>找到对应的dashboard-admin-token-dhpnm名字的账号后，利用<code>kubectl describe secrets dashboard-admin-token-dhpnm -n kube-system</code>获取token进行登录</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/05/05/hello-world/"/>
      <url>/2022/05/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
